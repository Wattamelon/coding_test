## 문제 핵심
- 1부터 number까지 각 수의 약수 개수를 구하고, limit 초과 시 power로 대체하여 합산

---

## 떠올려야 하는 관찰(사고 포인트)
- number가 최대 100,000이므로 각 수마다 약수를 직접 세면 비효율 가능
- 약수 개수는 누적 방식으로 한 번에 계산 가능

---

## 핵심 아이디어 / 기술
- 에라토스테네스 체 응용
  - 소수 판별이 아니라 “배수 순회” 구조만 차용
  - i를 약수로 가지는 모든 수(j = i, 2i, 3i, …)의 카운트를 1씩 증가
  - 모든 i에 대해 수행하면 각 수의 약수 개수가 완성됨
- 대안: 제곱근까지 순회하며 약수 쌍 계산

---

## 실수 포인트 / 헷갈리는 부분
- 제곱수에서 약수를 2개가 아닌 1개로 세야 함
- limit 초과 여부 비교 위치 실수
- 1번 기사(약수 1개) 누락 주의

---

## 시간복잡도 / 왜 통과되는지
- solution_byGPT: O(n log n)
  - 배수 누적 방식으로 100,000까지 안정적
- alt_solution: O(n √n)
  - 최악 기준에서도 제한 시간 내 통과 가능
