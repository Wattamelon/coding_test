[문제 요약]
- 이 문제에서 말하는 "부분 문자열"은 연속(substring)이 아니라, 순서만 유지하면 되는 부분 수열(subsequence) 판정이다.
- t에서 몇 개 문자를 삭제(순서 유지)해서 s를 만들 수 있으면 Yes, 아니면 No.
- while,try,except 기억하기

1) 이 문제에서 습득해야 하는 기술/방법

    1. 투 포인터(그리디 스캔) 패턴
        - i = 0 : s에서 "다음으로 맞춰야 하는 문자" 인덱스
        - t를 왼쪽부터 끝까지 1번 순회하면서
            - t의 현재 문자 == s[i] 이면 i += 1
        - 최종적으로 i == len(s) 이면 성공(Yes)

    2. 정답 판정 핵심
        - 매칭된 문자들을 tmp 같은 리스트에 저장할 필요가 없다.
        - "s의 포인터 i가 끝까지 도달했는가"만 보면 된다.

    3. 시간/메모리 목표
        - 시간: 테스트케이스 1개당 O(|t|)
            - t를 딱 1번만 훑는 구조
        - 메모리: O(1)
            - 추가 리스트/문자열을 누적하지 않음

    4. EOF(여러 테스트케이스) 입력 처리
        - try/except로 EOF 처리도 가능하지만, 더 깔끔한 방식:
            - for line in sys.stdin: 로 끝까지 읽기

    5. 피해야 할 구현(느려질 수 있음)
        - list.pop(0)
            - 맨 앞 원소 삭제는 내부적으로 한 칸씩 당겨서 O(n)이라 최악에서 터질 수 있음
        - tmp 누적 후 비교
            - 필요 없는 저장/비교 때문에 상수항(실제 시간)이 커짐


2) 내 코드 리뷰(현재 코드 기준)

    [좋은 점]
        - sys.stdin.readline 사용: 입력이 많은 상황에서 유리
        - 투 포인터 접근 자체는 문제 정의에 정확히 맞는 방향

    [아쉬운 점(느려지는 이유)]
        - tmp.append(...) 로 매칭 결과를 계속 저장함 (불필요)
        - s = list(s) 로 불필요한 변환을 함 (문자열 인덱싱으로 충분)
        - if s == tmp 는 리스트 전체 비교라 O(|s|) 추가 비용이 생김

    [개선 포인트(핵심)]
        - tmp를 없애고, i == len(s) 여부만으로 Yes/No 판정하면 더 깔끔하고 보통 더 빠름

