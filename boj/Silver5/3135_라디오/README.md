[문제 요약]
- 현재 주파수 A에서 목표 주파수 B로 이동할 때 버튼 최소 횟수 구하기
- 버튼 종류
  1) +1 MHz
  2) -1 MHz
  3) 즐겨찾기 N개: 누르면 해당 주파수로 “바로 이동” (N ≤ 5)
- 목표: 최소 버튼 횟수

---

1) 이 문제에서 습득해야 하는 기술/방법

    1. "후보 비교"로 최소값 찾기 (브루트포스/그리디)
        - 가능한 이동 방법은 크게 2개뿐임
            A) +/- 버튼만으로 A -> B
            B) 즐겨찾기 한 번 눌러서 f로 이동 후, +/-로 f -> B
        - N이 최대 5라서 즐겨찾기 전부 다 비교하면 끝

    2. 최소값 공식
        - 기본값(즐겨찾기 안 씀): 
            ans = abs(A - B)
        - 즐겨찾기 f를 쓸 때:
            ans = min(ans, 1 + abs(f - B))
            (즐겨찾기 버튼 1번 + 이후 +/- 이동)

    3. 복잡도 감각
        - 시간: O(N) (N ≤ 5라 사실상 상수)
        - 메모리: O(1)로도 가능 (굳이 리스트/정렬 필요 없음)

---

2) 내 코드 리뷰

    [좋은 점]
        - 핵심 아이디어는 맞음:
            - "그냥 이동(abs(A-B))" vs "즐겨찾기 1번 + abs(f-B)" 비교
        - 즐겨찾기 후보를 abs(f - B)로 바꿔서 계산한 것도 방향이 맞음

    [아쉬운 점 / 개선 포인트]
        - z 리스트를 만들고 sort() 할 필요가 없음
            - N이 5라 정렬해도 상관은 없지만, 문제 핵심은 "최솟값"만 필요함
            - min()으로 한 번에 처리 가능
        - cnt 변수는 사용되지 않음 (지워도 됨)
        - 코드가 조금 더 직관적으로 될 수 있음:
            - "정답 ans를 두고, 즐겨찾기마다 ans 갱신" 형태가 읽기 편함

---

3) 더 깔끔하고 직관적인 정답 코드(추천)

```python
import sys
input = sys.stdin.readline

a, b = map(int, input().split())
n = int(input())

ans = abs(a - b)  # 즐겨찾기 없이 이동

for _ in range(n):
    f = int(input())
    ans = min(ans, 1 + abs(f - b))  # 즐겨찾기 1번 + 이후 +/- 이동

print(ans)
