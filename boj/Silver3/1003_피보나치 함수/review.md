# 피보나치 함수 (BOJ 1003) — review.md

## 문제 핵심
- 원래 피보나치 재귀함수는 `fibonacci(n)`을 호출할 때 내부에서 `fibonacci(n-1)`, `fibonacci(n-2)`를 재귀로 호출함
- 이때 `n==0`이면 "0"을 출력하고, `n==1`이면 "1"을 출력함
- 목표는 **fibonacci(n)을 호출했을 때 "0"이 몇 번, "1"이 몇 번 출력되는지**를 구하는 것

---

## 핵심 아이디어 (DP로 바꾸는 사고)
피보나치 “값”을 구하지 말고, **출력 횟수의 쌍**을 DP로 잡는다.

- `Z[n]` = fibonacci(n) 호출 시 0 출력 횟수  
- `O[n]` = fibonacci(n) 호출 시 1 출력 횟수  

그럼 호출 구조가 똑같아서 **출력 횟수도 합쳐진다.**

- fibonacci(n)은 fibonacci(n-1) + fibonacci(n-2)를 호출
- 따라서
  - `Z[n] = Z[n-1] + Z[n-2]`
  - `O[n] = O[n-1] + O[n-2]`

---

## 베이스(초기값) 설정
재귀 정의 그대로:

- n=0: "0" 1번, "1" 0번 → `(1, 0)`
- n=1: "0" 0번, "1" 1번 → `(0, 1)`

이 두 개만 정확히 박아두면, 나머지는 점화식으로 자동으로 채워진다.

---

## 코테에서 좋은 구현 패턴 2가지
### 1) 전처리(0~40) 미리 만들어두기 (가장 안정적/빠름)
- N 최대가 40이라서 미리 dp[0..40] 다 만들어두면 끝
- 테스트케이스가 많아도 매번 O(1)

### 2) lazy 확장(필요할 때만 dp 늘리기)
- 입력으로 큰 n이 나오면 그때까지 dp를 append로 확장
- 여러 테스트케이스가 있어도 “최대 n”까지만 한 번 확장됨

---

## 내가 헷갈리기 쉬운 포인트 (실수 방지)
- dp는 “마지막 원소(dp[-1])”로 출력하지 말고 **반드시 dp[n]으로 출력**
  - dp를 확장하는 방식이면 dp[-1]이 dp[n]이긴 하지만, 습관적으로 dp[n]이 더 안전하고 직관적임

---

## 한 줄 요약
- 이 문제는 피보나치 값을 구하는 문제가 아니라,
  **(0 출력 횟수, 1 출력 횟수)**를 피보나치처럼 DP로 누적하는 문제다.
- 점화식은 그대로:
  - `dp[n] = dp[n-1] + dp[n-2]` (튜플끼리 성분별 합)
