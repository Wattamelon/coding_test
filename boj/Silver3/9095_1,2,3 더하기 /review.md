(1) solution_byGPT.py 설명(코테용 최적)

아이디어(점화식)

n을 만드는 마지막 수는 1 or 2 or 3 중 하나임

마지막이 1이면: 그 앞은 n-1을 만드는 모든 방법

마지막이 2이면: 그 앞은 n-2를 만드는 모든 방법

마지막이 3이면: 그 앞은 n-3을 만드는 모든 방법

그래서

dp[n] = dp[n-1] + dp[n-2] + dp[n-3]

초기값은 직접 세면 됨

dp[1] = 1 → (1)

dp[2] = 2 → (1+1, 2)

dp[3] = 4 → (1+1+1, 1+2, 2+1, 3)


“경우의 수” 문제면, 먼저 마지막 한 수를 고정해본다
n을 만드는 마지막 숫자는 1, 2, 3 중 하나잖아.

마지막이 1이면 → 그 앞은 n-1을 만드는 모든 방법

마지막이 2이면 → 그 앞은 n-2를 만드는 모든 방법

마지막이 3이면 → 그 앞은 n-3을 만드는 모든 방법

이렇게 “큰 문제를 작은 문제로 쪼개는” 순간 DP 냄새가 남.

그래서 점화식이 자동으로 나온다
서로 겹치지 않는 경우들이라 그냥 더하면 됨.

![스크린샷 2026-01-22 오후 7.06.55.png](..%2F..%2F..%2F..%2F..%2F..%2Fvar%2Ffolders%2F94%2Fgprcpx957ln74hchxvdmw6bm0000gn%2FT%2FTemporaryItems%2FNSIRD_screencaptureui_okmNTV%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202026-01-22%20%EC%98%A4%ED%9B%84%207.06.55.png)

여기서 중요한 감각:

“마지막이 뭐냐”로 나누면 중복 없이 전체를 다 덮는 경우가 많다.

이게 DP 점화식 만드는 가장 흔한 방식임.

초기값은 그냥 손으로 세서 박는다
DP는 초기값 2~3개만 확실하면 나머지는 점화식이 다 만들어줌.

dp[1] = 1 → (1)

dp[2] = 2 → (1+1, 2)

dp[3] = 4 → (1+1+1, 1+2, 2+1, 3)

이거 세 개 박으면 끝.

“왜 11까지 미리 만들지?”도 자연스럽게 됨
테스트케이스가 여러 개라서,

매번 계산하면 비효율

최대 n=11이니까 dp[1..11]을 한 번만 채워두고 답만 출력