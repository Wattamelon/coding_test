# 소수 판별 / 에라토스테네스의 체 — review.md

## 내가 헷갈렸던 포인트 (n/2 vs √n)
- 나는 “n이 소수인지 보려면 n/2까지 나눠보면 된다”고 생각했다.
- 이 생각은 **틀리진 않지만 너무 비효율적**이다.
- 실제로는 **√n까지만 나눠보면 충분**하다.

---

## 왜 √n까지만 보면 되나? (핵심 논리)
- n이 소수가 아니라면(합성수라면) 반드시 다음처럼 쪼개진다.
  - `n = a * b`
- 여기서 중요한 사실:
  - `a`와 `b`가 **둘 다 √n보다 클 수는 없다.**
  - 둘 다 √n보다 크다고 가정하면:
    - `a * b > √n * √n = n`
    - 즉, n을 만들 수가 없다 → 모순
- 따라서 합성수라면:
  - `a` 또는 `b` 중 **하나는 반드시 √n 이하**
- 결론:
  - n이 소수인지 확인하려면 **2부터 √n까지만** 나눠보면 된다.
  - n/2까지 볼 필요가 없다.

---

## 체(에라토스테네스)에서 왜 √n까지만 반복하나?
- 체는 “소수 i를 찾으면 i의 배수들을 지우는 방식”이다.
- 그런데 i가 √n보다 커지면:
  - `i * i > n`
  - 즉, 배수 지우기를 `i*i`부터 시작하는데, 시작점 자체가 범위를 넘어가 버린다.
- 또 중요한 점:
  - `2i, 3i, ...` 같은 작은 배수들은 이미 더 작은 소수 단계에서 지워진 상태다.
- 결론:
  - 체에서는 i를 **√n까지만** 돌리면 충분하다.
  - √n 이후는 “새로 지울 배수 시작점(i*i)”이 없어서 의미가 없다.

---

## 내가 질문했던 코드 부분 정리: `limit = int(n**0.5)`
- 이 코드는 “n의 절반까지”가 아니라 “n의 제곱근까지만” 보겠다는 의미다.
- 소수 판별에서도, 체에서도 똑같이 쓰이는 대표 최적화 포인트다.

---

## 내가 질문했던 슬라이스 대입은 뭐랑 같나?
- 이런 코드가 있었다:
  - `is_prime[start:n+1:step] = [False] * k`
- 이건 사실상 아래 for문을 “한 번에” 처리한 것과 같다.
  - `for i in range(start, n+1, step): 
    -     is_prime[i] = False`
- 단, `is_prime[i] = [False]` 처럼 쓰면 안 되고 반드시 `False` 하나를 넣어야 한다.

---

## 코테에서 가져가야 하는 결론
- “소수 판별 = √n까지만”
- “체의 반복 범위도 √n까지만”
- n이 커질수록 `n/2`와 `√n`의 차이가 엄청 커져서, 시간에서 크게 갈린다.
