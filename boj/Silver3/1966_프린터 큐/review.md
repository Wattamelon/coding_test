## 프린터 큐 (BOJ 1966) — review.md

## 문제 핵심
- 큐 맨 앞 문서를 확인한다.
- 뒤에 **더 높은 중요도**가 하나라도 있으면 인쇄하지 않고 **맨 뒤로 보낸다**.
- 아니면 **인쇄(출력 순서 +1)** 한다.
- 목표: **처음 위치가 M인 문서가 몇 번째로 인쇄되는지** 구한다.

---

## 내가 이 문제에서 습득해야 하는 기술/방법

### 1) 큐 시뮬레이션(Deque)
- 동작이 “앞에서 빼기(pop left) / 뒤로 넣기(append)”라서 `deque`가 정석.
- 원소를 `(priority, idx)` 형태로 넣으면 **타겟 문서 추적**이 쉬움.

### 2) 핵심은 “현재 최대 중요도”를 빠르게 판단하는 것
- (나쁜 패턴) 매번 `max(queue)`로 확인 → 최악 `O(n^2)`라서 n이 커지면 위험
- (괜찮은 패턴) 힙(heapq)로 최대값 관리 → 대체로 `O(n log n)`
- (이 문제 최적) **카운팅(빈도 배열)** → 중요도가 1~9라서 가능, 구현도 빠르고 사실상 `O(n)`

### 3) 왜 카운팅이 최강이냐 (중요도 범위가 작아서)
- 중요도가 1~9라 “최대 중요도” 후보가 9개뿐
- 그래서 “현재 남은 문서 중 가장 높은 중요도”를 거의 상수 시간으로 갱신 가능
- n이 커질수록 힙보다도 유리해질 수 있음(상수 비용이 작음)

---

## 내 코드(힙 + 큐) 리뷰

### 좋았던 점
- `(priority, idx)`로 저장해서 타겟 문서를 정확히 추적함.
- “높은 중요도부터 처리”하려고 힙을 쓴 방향 자체는 합리적임.
- 일반화된 형태(중요도 범위가 클 때)에도 통하는 접근임.

### 아쉬운 점 / 개선 포인트
1) **이 문제 한정으로는 힙이 과함**
- 중요도 범위가 1~9라서 힙을 쓰면 코드가 길어지고 상수 시간이 늘 수 있음.
- 카운팅 풀이가 더 짧고 더 빠르기 쉬움.

2) 큐 회전(while로 앞을 맞추는 부분)에서 불필요한 이동이 늘 수 있음
- 힙에서 뽑은 값과 큐 front가 맞을 때까지 계속 rotate/append를 반복 → 구현 상 “움직임”이 많아짐.

3) 코테 관점: 실수 포인트 증가
- 힙+큐 조합은 로직이 길어져서 인덱스/조건 실수가 나오기 쉬움.
- 이 문제는 “카운팅 + deque”가 더 안전한 편.

---

## 결론(코테 관점)
- **BOJ 1966은 중요도 1~9 고정**이라서
  - “카운팅(빈도 배열) + deque 시뮬레이션”이 가장 코테 친화적(짧고 빠름).
- 다만 “중요도 범위가 큰 변형 문제”라면
  - 힙 접근이 더 의미가 커짐.

---

## 한 줄 요약
- 이 문제의 진짜 핵심은 “현재 최대 중요도를 싸게 확인하는 방법”이고,
- 중요도 1~9 덕분에 **카운팅 풀이가 가장 깔끔하고 빠른 정석**이다.
