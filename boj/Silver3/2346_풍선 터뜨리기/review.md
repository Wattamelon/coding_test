# 풍선 터뜨리기 (BOJ 2346) — review.md

## 문제 핵심
- 원형으로 놓인 풍선을 1번부터 시작해 하나씩 터뜨린다.
- 풍선을 터뜨리면, 그 안의 정수(step)만큼 이동해서 다음 풍선을 터뜨린다.
  - 양수: 오른쪽 이동
  - 음수: 왼쪽 이동
- 이미 터진 풍선은 이동할 때 “건너뛰어야” 한다.
- 출력: 터진 풍선 번호 순서.

---

## 이 문제에서 진짜 중요한 포인트
- “이미 터진 풍선을 건너뛰기”를 `visited`로 처리하려고 하면 구현이 길어지고 실수 포인트가 늘어난다.
- 제일 좋은 모델링은 **터진 풍선을 자료구조에서 아예 제거**하는 것.
  - 그러면 “건너뛰기”는 자동으로 해결된다.
  - 원형 이동은 `deque` 회전(또는 pop+push 반복)으로 구현한다.

---

## 코테에서 쓰기 좋은 정석 풀이 아이디어 (Deque 시뮬레이션)
- 덱에 `(풍선번호, step)`을 저장한다.
- 매 반복마다:
  1) `popleft()`로 현재 풍선을 터뜨린다 → 덱에서 제거됨(중요)
  2) 출력 리스트에 풍선번호를 추가한다.
  3) 덱이 비어있지 않으면 step만큼 이동해서 “다음 풍선이 덱 맨 앞”에 오게 만든다.

---

## rotate 방향 감각(헷갈리기 쉬운 부분)
- `deque.rotate(k)` 의미:
  - `rotate(+k)` : 오른쪽으로 k칸 회전 (뒤가 앞으로)
  - `rotate(-k)` : 왼쪽으로 k칸 회전 (앞이 뒤로)

우리가 하고 싶은 것:
- “다음에 터뜨릴 풍선이 dq[0]이 되도록” 회전시키기

---

## 왜 양수일 때는 (step - 1) 보정이 들어가나?
- 풍선을 `popleft()`로 꺼내 터뜨린 순간,
  - 덱의 맨 앞(dq[0])은 이미 “현재 위치 기준 오른쪽 1칸”인 풍선이다.
- 그래서 step이 양수(오른쪽 이동)라면:
  - 이미 1칸 이동한 상태이므로 **추가로 step-1칸만 더** 이동하면 된다.
- 이 보정을 안 하면 양수 이동에서 한 칸 더 가버리는 오프바이원(off-by-one) 실수가 난다.

---

## 왜 rotate 코드에서 둘 다 마이너스로 보이는데 동작은 다르냐?
- 예시 형태:
  - step > 0  → `dq.rotate(-(step - 1))`  (결과는 음수 → 왼쪽 회전)
  - step < 0  → `dq.rotate(-step)`        (step이 음수라 -step은 양수 → 오른쪽 회전)

즉,
- 겉으로 `-`가 붙어있어도,
  - step이 음수면 `-step`은 양수가 되어 “오른쪽 회전”이 된다.
- 결과적으로 양수/음수에 따라 회전 방향이 갈라진다.

---

## 내 풀이 스타일 비교 (visited 스캔 vs deque 제거)
### visited + 인덱스 스캔 방식
- 장점: 직관적으로 보일 수 있음(배열 느낌)
- 단점:
  - “터진 풍선 건너뛰기” 때문에 while로 계속 스캔해야 해서 코드가 길어짐
  - 실수 포인트(인덱스 래핑, visited 체크 타이밍) 증가
  - 문제 모델링과 자료구조가 어긋남

### deque에서 제거하며 이동(정석)
- 장점:
  - 터진 풍선은 덱에서 사라져서 “건너뛰기”가 자동 해결
  - 이동은 rotate 혹은 pop+push로 깔끔하게 표현됨
  - 코테에서 가장 안정적이고 실수 적음
- 단점:
  - rotate 부호/보정(step-1) 감각을 한 번 잡아야 함

---

## rotate가 없는 언어라면?
- rotate가 없어도 동일하게 가능:
  - 오른쪽 이동: `popleft()`해서 `append()`를 반복
  - 왼쪽 이동: `pop()`해서 `appendleft()`를 반복
- 더 정석적인 대안으로는:
  - `next/prev` 배열로 원형 양방향 연결리스트를 흉내내서
    - O(1) 삭제 + 필요한 만큼 이동
  - (언어 무관하게 안정적인 패턴)

---

## 한 줄 요약
- 이 문제는 `visited`로 남겨두고 스캔하기보다,
  **deque에서 풍선을 제거하면서 이동을 회전으로 모델링**하는 게 코테용 정석이다.
- rotate는 “다음 풍선을 dq[0]으로 맞추는 작업”이고,
  양수일 때 (step-1) 보정이 들어가는 이유는 `popleft()` 이후 이미 1칸 이동한 상태이기 때문이다.
