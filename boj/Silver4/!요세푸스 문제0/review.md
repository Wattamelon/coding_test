[좋은 점]
- visited로 제거 여부를 관리하면서 원형으로 계속 돌게 만든 아이디어는 맞음
- visited가 True면 cnt를 안 올리고 idx만 넘기는 것도 맞는 처리

[아쉬운 점]
1) 원형 처리
- idx >= n일 때 `idx -= n`은 한 번만 줄이는데,
  사실 idx가 n보다 훨씬 커질 수도 있어서 안전하게는 `idx %= n`이 더 명확함
  (물론 너 코드는 idx를 1씩만 올려서 실제론 크게 문제는 안 생김)

2) 출력 로직이 길고 실수 포인트가 많음
- 결과 출력은 join으로 한 줄이면 끝남

# 요세푸스 문제 0 (solution_byGPT.py) (Deque + rotate 풀이) 정리 

## 핵심 아이디어
- 사람들을 원형으로 두고 K번째를 계속 제거해야 한다.
- `deque`(덱)를 쓰면 앞에서 빼는 연산(`popleft`)이 빠르다.
- 매번 K번째를 직접 세지 않고,
  **큐를 회전(rotate)해서 “제거할 사람”을 맨 앞으로 가져온 뒤 popleft로 제거**한다.

---

## 사용한 자료구조: deque
- `deque`는 양쪽에서 `append / popleft`가 O(1)이라 빠르다.
- 리스트에서 `pop(0)`는 느리지만, `deque.popleft()`는 빠르다.

---

## 코드 흐름 설명

### 
1) 초기화
n, k = map(int, input().split())
q = deque(range(1, n + 1))
ans = []
2) 반복 제거
while q:
    q.rotate(-(k - 1))
    ans.append(q.popleft())

q.rotate(-(k - 1)) 의미

rotate(x)는 덱을 회전시키는 함수

rotate(1) : 오른쪽으로 1칸 (맨 뒤가 맨 앞으로)

rotate(-1) : 왼쪽으로 1칸 (맨 앞이 맨 뒤로)

우리는 “K번째 사람”을 제거해야 하므로,
왼쪽으로 (K-1)칸 회전하면
원래의 K번째 사람이 덱의 맨 앞(0번째)로 온다.

q.popleft() 의미

회전 후 맨 앞에 온 사람이 제거 대상이므로 popleft()로 제거한다.

제거된 사람을 ans에 저장한다.

예시로 직관 잡기 (N=7, K=3)

시작: [1, 2, 3, 4, 5, 6, 7]

rotate(-2) → [3, 4, 5, 6, 7, 1, 2]

popleft() → 3 제거

남은 큐: [4, 5, 6, 7, 1, 2]

이 과정을 반복하면 <3, 6, 2, 7, 5, 1, 4>가 나온다.

출력 포맷 처리
sys.stdout.write("<" + ", ".join(map(str, ans)) + ">")


ans의 숫자들을 문자열로 바꿔 ", "로 이어 붙인다.

문제 요구 형식인 < ... >를 붙여 출력한다.

복잡도

각 제거 단계마다 rotate와 popleft 수행

N ≤ 1000이라 충분히 빠르게 통과 가능