# 명예의 전당 (프로그래머스) — review.md

## 문제 핵심
- 매일 점수 `score[i]`가 들어옴
- 지금까지 나온 점수 중 **상위 k개만** “명예의 전당”에 유지
- 매일 출력해야 하는 값 = **명예의 전당의 최하위 점수(= 상위 k개 중 가장 작은 값)**

---

## 내가 떠올려야 하는 관찰(사고 포인트)
- “상위 k개”를 유지할 때, 매번 전체를 정렬하는 건 낭비가 큼
- 필요한 건 딱 2가지뿐:
  1) 상위 k개를 유지하기
  2) 그중 최솟값(최하위) 빠르게 보기

→ 즉, **상위 k개를 담는 자료구조 + 최솟값 접근**이 핵심

---

## 코테용 정석 풀이(최적): 최소 힙(min-heap)
- 파이썬 `heapq`는 **최소힙**
- 상위 k개를 힙에 넣어두면:
  - 힙의 최솟값 `heap[0]` = “명예의 전당 최하위 점수”
- 매일 처리 로직:
  - 아직 k개 미만이면 그냥 push
  - k개 꽉 찼으면:
    - 새 점수 `s`가 `heap[0]`보다 크면 교체(pop+push)
    - 아니면 무시
  - 매일 `heap[0]`를 답에 추가

### 왜 이게 맞나?
- 힙 안에는 항상 “지금까지 점수 중 상위 k개”만 남도록 만든다.
- 최하위 점수(`heap[0]`)는 “상위 k개 중 가장 작은 값”이므로 문제에서 발표하는 값과 동일.

---

## 시간 복잡도 비교 (왜 힙이 좋은가)
- k ≤ 100이라 정렬로도 통과는 가능하지만, 코테 습관으로는 힙이 더 정석

### 내 코드(매번 정렬)
- 매일 `sorted(nums)` 수행 → O(k log k)
- 전체는 대략 O(n * k log k)

### 힙 코드
- push/replace가 O(log k)
- 전체는 O(n log k)

---

## 내 코드 리뷰(현재 코드 기준)
### 좋은 점
- “상위 k개만 유지하고 최하위 출력”이라는 방향은 정확함
- k가 작아서(최대 100) 실제로는 통과 가능성이 높음

### 아쉬운 점(개선 포인트)
- 매일 `deque(sorted(nums))`로 “전체를 다시 정렬”하는 비용이 불필요
- `deque`를 쓸 이유가 거의 없음 (정렬 유지 목적이라면 리스트가 더 자연스럽고, 최적은 힙)

---

## 기억해둘 패턴(암기할 가치 있음?)
- **상위 k개 유지 + 최솟값 빠르게 출력** = “최소힙에 상위 k개 유지”는 코테에서 자주 나오는 패턴이라 익혀두는 게 좋다.
- 비슷한 유형:
  - “가장 큰 k개 유지”
  - “k번째로 큰 값/작은 값 계속 구하기”
  - “스트리밍 데이터에서 Top-K 유지”

---
